/* eslint-disable react-hooks/exhaustive-deps */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { useForm } from '@mantine/form';
import { getHotkeyHandler } from '@mantine/hooks';
import { zodResolver } from 'mantine-form-zod-resolver';
import React, { isValidElement, useEffect, useImperativeHandle, useState } from 'react';
import { ZodSchema } from 'zod';

import { Field, FieldType, UseFindUniqueHook, UseMutationHook } from '../metadata';
import { useZenstackUIProvider } from '../utils/provider';
import { getIdField, getModelFields } from '../utils/utils';
import { ZSBaseForm, ZSCreateFormProps, ZSFormType, ZSUpdateFormProps } from './base';

/** Generates the default state for the form */
const createDefaultValues = (fields: Record<string, Field>, type: ZSFormType) => {
	const defaultValueMap: Record<string, any> = {};
	Object.values(fields).forEach((field) => {
		if (field.isDataModel) return;
		const defaultAttr = field.attributes?.find(attr => attr.name === '@default');
		if (defaultAttr?.args?.[0]?.value) {
			defaultValueMap[field.name] = defaultAttr?.args?.[0]?.value;
		} else {
			// For create forms, we avoid using defaults. This is so autogenerated fields like id's can still work
			if (type === 'create') {
				if (field.type === FieldType.Boolean) defaultValueMap[field.name] = false;
				return;
			}

			// For update forms, we must set primitive defaults to avoid undefined values, which will cause errors with Mantine useForm
			if (field.type === FieldType.Boolean) {
				defaultValueMap[field.name] = false;
			} else if (field.type === FieldType.Int || field.type === FieldType.Float) {
				defaultValueMap[field.name] = 0;
			} else {
				defaultValueMap[field.name] = '';
			}
		}
	});
	return defaultValueMap;
};

/**
 * Cleans and connects data for foreign key fields
 * @param data - Data to clean
 * @param fields - Fields for the model
 * @returns Cleaned data
 * Example: { ownerName: 'John Doe', name: 'Item 1' } -> { owner: { connect: { name: 'John Doe' } }, name: 'Item 1' }
 */
const cleanAndConnectData = (data: Record<string, unknown>, fields: Record<string, Field>) => {
	// Create a clean copy of data
	const cleanData = { ...data };
	const connectorData: Record<string, unknown> = {};

	// Iterate through foreign key fields
	Object.values(fields).forEach((field) => {
		if (!field.isForeignKey) return;
		const relationField = fields[field.relationField!];
		const relationIdKey = Object.keys(relationField.foreignKeyMapping!)[0];
		const relationValue = cleanData[field.name];

		// If value exists, create connect object for the relation
		if (!relationValue) return;
		connectorData[field.relationField!] = {
			connect: {
				[relationIdKey]: relationValue,
			},
		};

		// Remove the foreign key field from clean data
		delete cleanData[field.name];
	});

	return { ...cleanData, ...connectorData };
};

/**
 * Captures currently focused element and returns a function to restore focus to it
 * @returns Function that restores focus to the previously active element
 */
const focusOnPrevActiveElement = () => {
	const activeElement = document.activeElement as HTMLElement;
	const dataPath = activeElement?.getAttribute('data-path');

	return () => {
		setTimeout(() => {
			const elementToFocus = document.querySelector(`[data-path="${dataPath}"]`) as HTMLElement;
			elementToFocus?.focus();
		}, 0);
	};
};

// --------------------------------------------------------------------------------
// Update Form
// --------------------------------------------------------------------------------
export const ZSUpdateForm = (props: ZSUpdateFormProps) => {
	const { hooks, schemas, metadata: originalMetadata, queryClient, globalClassName } = useZenstackUIProvider();
	const metadata = props.metadataOverride || originalMetadata;

	// Extract information
	const mainSchema = props.schemaOverride || schemas[`${props.model}Schema`]; // we don't use update schema because that will mark everything as optional
	const fields = getModelFields(metadata, props.model);
	const idField = getIdField(fields);

	// Fetch initial values
	const useFindUniqueHook = hooks[`useFindUnique${props.model}`] as UseFindUniqueHook<any>;
	const { data, isLoading: isLoadingInitialData } = useFindUniqueHook({ where: { [idField.name]: props.id } });

	// Setup update hook
	const [isLoadingUpdate, setIsLoadingUpdate] = useState(false);
	const useUpdateHook = hooks[`useUpdate${props.model}`] as UseMutationHook<any>;
	const update = useUpdateHook({ optimisticUpdate: true });

	// Setup form
	const form = useForm({
		mode: 'controlled', // Controlled mode is required for adaptive filters
		validate: zodResolver(mainSchema),
		initialValues: createDefaultValues(fields, 'update'),
		// validateInputOnBlur: true,
	});

	// Add useImperativeHandle to expose form object
	useImperativeHandle(props.formRef, () => ({
		form,
	}));

	// When the id changes, reset back to an empty form first before the new query starts
	useEffect(() => {
		const defaultValues = createDefaultValues(fields, 'update');
		form.setInitialValues(defaultValues);
		form.setValues(defaultValues);
		form.resetDirty();
	}, [props.id]);

	// Set initial values after data is fetched
	useEffect(() => {
		if (data) {
			// Get default values, and replace them with the newly fetched data
			const defaultValues = createDefaultValues(fields, 'update');
			for (const key in data) {
				if (data[key] !== undefined && data[key] !== null) defaultValues[key] = data[key];
			}

			form.setInitialValues(defaultValues);
			form.setValues(defaultValues);
			form.resetDirty();
		}
	}, [data]);

	// Handle update submit
	const handleUpdateSubmit = async (x: any) => {
		// We parse the data ourselves so that any zod transformations can be applied (ex: empty strings to nulls)
		const result = mainSchema.safeParse(x);
		if (!result.success) {
			console.error('Update data does not follow the schema:', result.error);
			return;
		}
		const values = result.data;

		setIsLoadingUpdate(true);

		try {
			// Only send dirty fields for the update query
			const dirtyFields = form.getDirty();
			const dirtyValues = Object.fromEntries(
				Object.entries(values as Record<string, unknown>)
					.filter(([key]) => dirtyFields[key])
					.map(([key, value]) => {
						// Convert empty strings to null for optional fields
						if (fields[key]?.isOptional && value === '') return [key, null];
						return [key, value];
					}),
			);
			// Generate update payload
			const cleanedData = cleanAndConnectData(dirtyValues, fields);
			const updatePayload = {
				where: { [idField.name]: props.id },
				data: cleanedData,
			};

			if (props.overrideSubmit) {
				await props.overrideSubmit(updatePayload);
				props.onSubmit?.(updatePayload);
				// Invalidate all queries for this model
				queryClient.invalidateQueries({
					predicate: (query) => {
						const queryKey = query.queryKey;
						return queryKey.includes(props.model);
					},
				});
			} else {
				await update.mutateAsync(updatePayload);
			}

			// Check if ID field was updated and trigger callbacks
			if (dirtyFields[idField.name]) props.onIdChanged?.(values[idField.name]);
			props.onSubmit?.(cleanedData);
		} catch (error) {
			console.error('Update failed:', error);
		} finally {
			setIsLoadingUpdate(false);
		}
	};

	// Reverts form to initial values and focuses on the last edited element
	const handleRevertShortcut = () => {
		const focus = focusOnPrevActiveElement();
		form.reset();
		focus();
	};

	return (
		<form
			className={`${globalClassName || ''} ${props.className || ''}`.trim()}
			onSubmit={form.onSubmit(handleUpdateSubmit)}
			onKeyDown={getHotkeyHandler([
				['meta+s', form.onSubmit(handleUpdateSubmit)],
				['mod+backspace', handleRevertShortcut],
			])}
		>
			<ZSBaseForm {...props} form={form} schema={mainSchema} type="update" isLoadingInitialData={isLoadingInitialData} isLoadingUpdate={isLoadingUpdate}>
				{props.children}
			</ZSBaseForm>
		</form>
	);
};

// --------------------------------------------------------------------------------
// Create Form
// --------------------------------------------------------------------------------
export const ZSCreateForm = (props: ZSCreateFormProps) => {
	const { hooks, schemas, metadata: originalMetadata, queryClient, globalClassName } = useZenstackUIProvider();
	const metadata = props.metadataOverride || originalMetadata;

	// Extract information
	const createSchema: ZodSchema = props.schemaOverride || schemas[`${props.model}CreateSchema`];
	const fields = getModelFields(metadata, props.model);

	// Setup create hook
	const [isLoadingCreate, setIsLoadingCreate] = useState(false);
	const useCreateHook = hooks[`useCreate${props.model}`] as UseMutationHook<any>;
	const create = useCreateHook({ optimisticUpdate: true });

	// Setup form
	const form = useForm({
		mode: 'controlled', // Controlled mode is required for adaptive filters
		validate: zodResolver(createSchema),
		initialValues: createDefaultValues(fields, 'create'),
		// validateInputOnBlur: true,
	});

	// Add useImperativeHandle to expose form object
	useImperativeHandle(props.formRef, () => ({
		form,
	}));

	// Handle create submit
	const handleCreateSubmit = async (x: any) => {
		// We parse the data ourselves so that any zod transformations can be applied (ex: empty strings to nulls)
		const result = createSchema.safeParse(x);
		if (!result.success) {
			console.error('Create data does not follow the schema:', result.error);
			return;
		}
		const values = result.data;

		setIsLoadingCreate(true);
		try {
			const cleanedData = cleanAndConnectData(values, fields);
			const createPayload = { data: cleanedData };

			if (props.overrideSubmit) {
				// For overrideSubmit, we omit the data key to keep it simpler
				await props.overrideSubmit(cleanedData);
				props.onSubmit?.(cleanedData);

				// Invalidate all queries for this model
				queryClient.invalidateQueries({
					predicate: (query) => {
						const queryKey = query.queryKey;
						return queryKey.includes(props.model);
					},
				});
			} else {
				await create.mutateAsync(createPayload);
				props.onSubmit?.(createPayload);
			}
		} catch (error) {
			console.error('Create failed:', error);
		} finally {
			setIsLoadingCreate(false);
		}
	};

	return (
		<form
			className={`${globalClassName || ''} ${props.className || ''}`.trim()}
			onSubmit={form.onSubmit(handleCreateSubmit)}
		>
			<ZSBaseForm model={props.model} form={form} schema={createSchema} type="create" isLoadingCreate={isLoadingCreate} metadataOverride={props.metadataOverride}>
				{props.children}
			</ZSBaseForm>
		</form>
	);
};

// --------------------------------------------------------------------------------
// Form customization components
// Exported for external use
// --------------------------------------------------------------------------------

/** A placeholder component will be replaced by the actual input component in the form. */
export const ZSFieldSlot = ({ fieldName, className, ...rest }: { fieldName: string, className?: string, [key: string]: any }) => {
	return <div className={className} {...rest} />;
};
const ZSFIELDSLOT_DISPLAY_NAME = 'ZenstackFormPlaceholder';
ZSFieldSlot.displayName = ZSFIELDSLOT_DISPLAY_NAME;

// Note: `fieldName` is used by `processChildren` and `hasCustomOrPlaceholder` to identify the custom field, but not inside the component itself
/** A custom element that will be controlled by the form. You do not need to pass values or data to it, but you can if you want. */
export const ZSCustomField = ({ fieldName, children }: { fieldName: string, children: React.ReactNode }) => {
	// Ensure there's exactly one child
	const childrenArray = React.Children.toArray(children);
	if (childrenArray.length !== 1 || !isValidElement(childrenArray[0])) {
		throw new Error('ZSCustomField must have exactly one child element');
	}

	return childrenArray[0];
};
const ZSCUSTOM_FIELD_DISPLAY_NAME = 'ZSCustomField';
ZSCustomField.displayName = ZSCUSTOM_FIELD_DISPLAY_NAME;
